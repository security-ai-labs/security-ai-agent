// ❌ Multiple Web2 and Web3 vulnerabilities in hybrid JavaScript/Web3 code

// ===================== WEB2 VULNERABILITIES =====================

// ❌ CRITICAL: Hardcoded secrets in source code
const PRIVATE_KEY = "0xabc123def456abc123def456abc123def456abc123def456abc123def456abc1";
const API_KEY = "sk-1234567890abcdefghijklmnopqrstuvwxyz";
const ADMIN_PASSWORD = "SuperSecretPassword123!";
const DATABASE_URL = "mongodb://user:password123@localhost:27017/mydb";

// ❌ CRITICAL: SQL Injection vulnerability
async function getUserData(userId) {
    const query = "SELECT * FROM users WHERE id = " + userId;  // ❌ String concatenation
    const result = await db.query(query);
    return result;
}

// ❌ HIGH: XSS vulnerability
function displayUserComment(comment) {
    document.getElementById('comments').innerHTML = comment;  // ❌ Direct HTML injection
}

// ❌ CRITICAL: Command injection
function executeBackup(filename) {
    const command = `backup.sh ${filename}`;
    exec(command);  // ❌ User input directly in shell command
}

// ❌ HIGH: Path traversal
function readFile(filepath) {
    return fs.readFileSync(filepath);  // ❌ No validation on path
}

// ===================== WEB3 VULNERABILITIES =====================

const ethers = require('ethers');

// ❌ CRITICAL: Private key exposure in Web2 context
const walletPrivateKey = "0xdef456abc123def456abc123def456abc123def456abc123def456abc123def4";
const wallet = new ethers.Wallet(walletPrivateKey);

// ❌ CRITICAL: Mnemonic exposure
const mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
const mnemonicWallet = ethers.Wallet.fromMnemonic(mnemonic);

// ❌ HIGH: Missing slippage protection in swap
async function swapTokens(amountIn) {
    const uniswapRouter = new ethers.Contract(ROUTER_ADDRESS, ROUTER_ABI, signer);
    
    // ❌ No minAmountOut - vulnerable to sandwich attacks
    const tx = await uniswapRouter.swapExactTokensForTokens(
        amountIn,
        0,  // ❌ CRITICAL: No minimum amount out
        [TOKEN_A, TOKEN_B],
        myAddress,
        Date.now() + 60
    );
    
    return tx;
}

// ❌ CRITICAL: Unverified price oracle
async function getTokenPrice(tokenAddress) {
    // ❌ Using uniswap getAmountsOut as price oracle (manipulable)
    const amounts = await uniswapRouter.getAmountsOut(1000000000000000000, [tokenAddress, USDC]);
    return amounts[1];
}

// ❌ HIGH: No signature verification
function processTransaction(data, signature) {
    // ❌ Missing ethers.utils.verifyMessage() call
    const result = performAction(data);
    return result;
}

// ❌ MEDIUM: Timestamp dependency in JavaScript
function claimDailyReward() {
    const now = Date.now() / 1000;
    
    // ❌ Can be manipulated by adjusting system time
    if (now % 86400 === 0) {
        processReward();
    }
}

// ===================== CODE GENERATION ISSUES =====================

// ❌ HIGH: AI-generated code without verification
// TODO: Verify this function works correctly
async function autoGeneratedContractInteraction() {
    try {
        const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
        const result = await contract.complexFunction();
        return result;
    } catch {
        // ❌ Empty catch - error suppression
    }
}

// ❌ MEDIUM: Incomplete error handling
async function riskyOperation() {
    const tx = await contract.transfer(recipient, amount);
    // ❌ Not awaiting confirmation
    return tx;
}

// ❌ HIGH: Missing input validation
function executeSwap(inputData) {
    // ❌ No validation on inputData
    const params = JSON.parse(inputData);
    return performSwap(params);
}

// ===================== CRYPTOGRAPHY ISSUES =====================

const crypto = require('crypto');

// ❌ CRITICAL: Weak random number generation
function generateNonce() {
    // ❌ Math.random() is NOT cryptographically secure
    return Math.random().toString(36).substring(7);
}

// ❌ HIGH: Weak hash function
function hashPassword(password) {
    // ❌ SHA1 is deprecated and weak
    return crypto.createHash('sha1').update(password).digest('hex');
}

// ❌ CRITICAL: Custom cryptography implementation
function customEncrypt(message, key) {
    // ❌ Never use custom crypto - this is insecure
    let encrypted = '';
    for (let i = 0; i < message.length; i++) {
        encrypted += String.fromCharCode(message.charCodeAt(i) ^ key.charCodeAt(i % key.length));
    }
    return encrypted;
}

// ===================== ARCHITECTURE ISSUES =====================

// ❌ MEDIUM: Centralized single point of failure
contract VulnerableDeFi {
    address onlyAdmin = msg.sender;  // ❌ Single owner
    
    function emergencyWithdraw() public onlyAdmin {  // ❌ No multisig
        // Anyone can block the protocol if admin key is compromised
    }
}

// ❌ HIGH: Centralized upgrade without timelock
async function upgradeContract(newImplementation) {
    // ❌ No timelock or multisig
    const proxyAdmin = new ethers.Contract(PROXY_ADMIN, ADMIN_ABI, signer);
    await proxyAdmin.upgrade(PROXY, newImplementation);
}

// ===================== UNSAFE PATTERNS =====================

// ❌ MEDIUM: Missing event logging
async function transferTokens(to, amount) {
    balances[to] += amount;
    balances[msg.sender] -= amount;
    // ❌ No Transfer event emitted
}

// ❌ HIGH: Trusting user input
async function executeLoan(params) {
    const amount = params.amount;  // ❌ User-provided without validation
    
    // Loan logic...
    return procesLoan(amount);
}

module.exports = {
    wallet,
    mnemonicWallet,
    swapTokens,
    getTokenPrice,
    processTransaction,
};