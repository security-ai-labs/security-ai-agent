{
  "ethereum": {
    "reentrancy": {
      "name": "Reentrancy Attack",
      "patterns": [
        "msg.sender.call{",
        ".call{value:",
        ".transfer(",
        "balances[msg.sender] -=",
        ".send("
      ],
      "severity": "CRITICAL",
      "description": "External call made before state variables are updated. Attacker can recursively call the function to drain funds.",
      "remediation": "Use the checks-effects-interactions pattern: verify, update state, then call external contracts. Or use OpenZeppelin's ReentrancyGuard modifier.",
      "examples": [
        "function withdraw(uint amount) public { (bool success,) = msg.sender.call{value: amount}(\"\"); balances[msg.sender] -= amount; }",
        "WRONG: Call before state update. RIGHT: Update balances first, then call."
      ],
      "references": [
        "SWC-107",
        "https://github.com/OpenZeppelin/openzeppelin-contracts"
      ],
      "exclude_patterns": [
        "ReentrancyGuard",
        "nonReentrant",
        "// protected",
        "checks-effects-interactions"
      ]
    },
    "tx_origin_authorization": {
      "name": "tx.origin Authorization",
      "patterns": [
        "tx.origin ==",
        "tx.origin !=",
        "require(tx.origin",
        "if(tx.origin"
      ],
      "severity": "CRITICAL",
      "description": "Using tx.origin for authorization instead of msg.sender. Attackers can spoof tx.origin via phishing attacks or delegatecall chains. tx.origin represents the original EOA, not the immediate caller.",
      "remediation": "Always use msg.sender for access control. Never use tx.origin for authorization. tx.origin should only be used in exceptional cases where you understand the security implications.",
      "examples": [
        "WRONG: require(tx.origin == owner, 'not authorized');",
        "RIGHT: require(msg.sender == owner, 'not authorized');"
      ],
      "references": [
        "SCWE-018",
        "https://scsfg.io/hackers/tx-origin/"
      ],
      "exclude_patterns": [
        "event ",
        "emit ",
        "// safe",
        "// ok",
        "// logging",
        "console.log"
      ],
      "required_context": [
        "owner",
        "admin",
        "auth",
        "require",
        "modifier"
      ],
      "context_window": 5
    },
    "unchecked_call_return": {
      "name": "Unchecked Low-Level Call Return",
      "patterns": [
        ".call(",
        ".delegatecall(",
        "success;",
        "(bool success, )"
      ],
      "severity": "CRITICAL",
      "description": "Low-level calls (.call, .delegatecall) return a boolean indicating success. Not checking this return value can lead to silent failures. If the call fails, execution continues as if nothing happened.",
      "remediation": "Always check the return value: require(success, 'call failed'). Or use high-level functions (transfer, send) which revert on failure. Never ignore the success boolean.",
      "examples": [
        "WRONG: (bool success, ) = to.call{value: amount}(\"\"); success;",
        "RIGHT: (bool success, ) = to.call{value: amount}(\"\"); require(success, 'transfer failed');"
      ],
      "references": [
        "SWC-104"
      ]
    },
    "integer_overflow": {
      "name": "Integer Overflow/Underflow",
      "patterns": [
        "pragma solidity ^0.7",
        "pragma solidity ^0.6",
        "pragma solidity ^0.5",
        "pragma solidity 0.4",
        "balanceOf[msg.sender] -=",
        "totalSupply +="
      ],
      "severity": "CRITICAL",
      "description": "Solidity versions before 0.8.0 do not have built-in overflow/underflow protection. Integer arithmetic can wrap around causing unexpected behavior. Example: 0 - 1 = max uint256.",
      "remediation": "Upgrade to Solidity 0.8.0 or later which has built-in overflow checks. For older contracts, use SafeMath library from OpenZeppelin for all arithmetic operations.",
      "examples": [
        "Solidity < 0.8: uint256 balance = 0; balance -= 1; // wraps to max uint256",
        "Solidity 0.8+: uint256 balance = 0; balance -= 1; // reverts automatically"
      ],
      "references": [
        "SWC-101",
        "SC08:2025"
      ]
    },
    "missing_zero_address": {
      "name": "Missing Zero Address Check",
      "patterns": [
        "transfer(address to,",
        "transferFrom(address from, address to,",
        "address(0)",
        "require(address"
      ],
      "severity": "HIGH",
      "description": "Transfers to address(0) are mistakes that lose funds forever. Code should validate recipient is not the zero address. This is especially critical in token contracts.",
      "remediation": "Add explicit check: require(to != address(0), 'Cannot transfer to zero address'). Apply this check to all functions that accept an address as recipient.",
      "examples": [
        "WRONG: function transfer(address to, uint amount) public { balanceOf[msg.sender] -= amount; balanceOf[to] += amount; }",
        "RIGHT: function transfer(address to, uint amount) public { require(to != address(0), 'Invalid address'); balanceOf[msg.sender] -= amount; balanceOf[to] += amount; }"
      ],
      "references": [
        "SWC-110"
      ]
    },
    "missing_access_control": {
      "name": "Missing Access Control",
      "patterns": [
        "function mint(",
        "function burn(",
        "function transferFrom(",
        "public {",
        "external {"
      ],
      "severity": "HIGH",
      "description": "Critical functions lack access control checks. Anyone can call functions meant only for specific users (owner, admin, etc). This is especially dangerous for mint, burn, and administrative functions.",
      "remediation": "Add access control modifiers like onlyOwner, onlyAdmin, or use role-based access control (RBAC). Use OpenZeppelin's Ownable or AccessControl. Verify sender is authorized before executing critical operations.",
      "examples": [
        "WRONG: function transferFrom(address from, address to, uint amount) external { balanceOf[from] -= amount; balanceOf[to] += amount; }",
        "RIGHT: function transferFrom(address from, address to, uint amount) external { require(msg.sender == from || allowance[from][msg.sender] >= amount, 'Not authorized'); ... }"
      ],
      "references": [
        "SWC-107"
      ]
    },
    "unchecked_account": {
      "name": "Unchecked Account Injection",
      "patterns": [
        "if (isContract(to))",
        "isContract(account)",
        "extcodesize",
        "assembly"
      ],
      "severity": "HIGH",
      "description": "Using extcodesize checks for contract detection can be unreliable. Contracts can self-destruct, making the check return false positives. Using contract existence checks for security decisions is dangerous.",
      "remediation": "Avoid relying on isContract() for security decisions. If you must check contract existence, be aware of edge cases. Use robust methods or implement proper token callback standards (ERC223, ERC777).",
      "examples": [
        "WRONG: if (isContract(to)) { /* do something */ }",
        "RISKY: Using assembly { size := extcodesize(account) } for authorization"
      ],
      "references": [
        "SWC-108"
      ]
    },
    "missing_balance_check": {
      "name": "Missing Balance Validation",
      "patterns": [
        "balanceOf[msg.sender] -=",
        "balanceOf[from] -=",
        "transfer(",
        "transferFrom("
      ],
      "severity": "HIGH",
      "description": "Functions that deduct balances don't verify sufficient balance exists first. In pre-0.8 Solidity, this causes silent underflow instead of reverting. Funds can be transferred when balance is insufficient.",
      "remediation": "Always check balance before subtraction: require(balanceOf[msg.sender] >= amount, 'Insufficient balance'). Upgrade to Solidity 0.8+ which automatically reverts on underflow.",
      "examples": [
        "WRONG: function transfer(address to, uint amount) { balanceOf[msg.sender] -= amount; balanceOf[to] += amount; }",
        "RIGHT: function transfer(address to, uint amount) { require(balanceOf[msg.sender] >= amount, 'Insufficient'); balanceOf[msg.sender] -= amount; balanceOf[to] += amount; }"
      ],
      "references": [
        "SWC-101"
      ]
    },
    "allowance_not_validated": {
      "name": "Missing Allowance Validation",
      "patterns": [
        "transferFrom(",
        "allowance[from][msg.sender] -=",
        "allowance["
      ],
      "severity": "MEDIUM",
      "description": "transferFrom doesn't validate that the spender has sufficient allowance before executing the transfer. Combined with underflow vulnerabilities, this can cause silent failures.",
      "remediation": "Always check allowance before spending: require(allowance[from][msg.sender] >= amount, 'Allowance exceeded'). Use standard ERC20 implementation or OpenZeppelin's SafeERC20.",
      "examples": [
        "WRONG: function transferFrom(address from, address to, uint amount) { allowance[from][msg.sender] -= amount; balanceOf[from] -= amount; balanceOf[to] += amount; }",
        "RIGHT: function transferFrom(address from, address to, uint amount) { require(balanceOf[from] >= amount, 'Insufficient balance'); require(allowance[from][msg.sender] >= amount, 'Allowance exceeded'); ... }"
      ],
      "references": [
        "SWC-123"
      ]
    },
    "delegatecall_injection": {
      "name": "Delegatecall to Untrusted Address",
      "patterns": [
        "delegatecall(",
        ".delegatecall(msg.data)",
        "delegatecall(user",
        "delegatecall(input"
      ],
      "severity": "CRITICAL",
      "description": "delegatecall executes code in the context of the calling contract. If the target address is user-controlled, attacker can execute arbitrary code and modify contract state.",
      "remediation": "Never allow user-controlled addresses in delegatecall. If necessary, maintain a whitelist of allowed addresses and validate against it. Use OpenZeppelin's Proxy pattern.",
      "examples": [
        "WRONG: (bool success,) = target.delegatecall(msg.data); // target is user input",
        "RIGHT: require(whitelistedAddresses[target], 'Not whitelisted'); (bool success,) = target.delegatecall(msg.data);"
      ],
      "references": [
        "SWC-112"
      ],
      "exclude_patterns": [
        "whitelistedAddresses",
        "require(whitelisted",
        "onlyWhitelisted",
        "// trusted"
      ],
      "required_context": [
        "public",
        "external",
        "user",
        "input",
        "param",
        "msg.sender",
        "target",
        "address"
      ],
      "context_window": 3
    },
    "timestamp_dependency": {
      "name": "Timestamp Dependency",
      "patterns": [
        "block.timestamp",
        "now >"
      ],
      "severity": "MEDIUM",
      "description": "Smart contracts relying on block.timestamp for critical logic are vulnerable. Miners can manipulate timestamps within a small range (usually \u00b115 seconds).",
      "remediation": "Use block.number instead of block.timestamp for ordering events. Or accept that timestamps can vary by ~15 seconds and design logic accordingly.",
      "examples": [
        "RISKY: if (block.timestamp > deadline) { ... }",
        "BETTER: if (block.number > blockDeadline) { ... }"
      ],
      "references": [
        "SWC-116"
      ]
    },
    "flash_loan": {
      "name": "Flash Loan Attack",
      "patterns": [
        "flashLoan",
        "receiveFlashLoan",
        "balance before",
        "balance after"
      ],
      "severity": "CRITICAL",
      "description": "Contracts that verify state after receiving a flash loan are vulnerable. Attacker can borrow huge amounts, manipulate prices, then repay atomically.",
      "remediation": "Use trusted price oracles (Chainlink). Implement balance checks that account for the possibility of flash loans. Use multiple price sources.",
      "examples": [
        "WRONG: uint balanceBefore = token.balanceOf(address(this)); flashLoan(amount); require(token.balanceOf(address(this)) >= balanceBefore);",
        "RIGHT: Use Chainlink oracle price instead of checking balance"
      ],
      "references": [
        "https://github.com/amanusk/flashLoanAttack"
      ]
    },
    "front_running": {
      "name": "Front-Running Vulnerability",
      "patterns": [
        "tx.gasprice",
        "block.basefee",
        "mempool",
        "pending"
      ],
      "severity": "HIGH",
      "description": "Transactions are visible in mempool before inclusion. Attackers can front-run by placing their transaction before yours, affecting price/order.",
      "remediation": "Use commit-reveal schemes. Use MEV protection services. Use private mempools. Implement order batching.",
      "examples": [
        "VULNERABLE: Swap price visible in mempool, attacker can front-run",
        "PROTECTED: Use commit-reveal or private transaction pool"
      ],
      "references": [
        "https://github.com/manifoldfinance/mev-inspect"
      ]
    }
  },
  "solana": {
    "missing_signer_check": {
      "name": "Missing Signer Check",
      "patterns": [
        "is_signer == false",
        "is_signer: false",
        "!account.is_signer"
      ],
      "severity": "CRITICAL",
      "description": "Solana accounts that are not verified as signers can be spoofed. Attacker can pass arbitrary accounts without providing their private key.",
      "remediation": "Always verify is_signer = true: require!(account.is_signer, ErrorCode::SignerMissing)",
      "examples": [
        "WRONG: pub struct Instruction { pub signer: AccountInfo }  // No is_signer check",
        "RIGHT: #[account(signer)] pub signer: Signer"
      ],
      "references": [
        "https://docs.anchor-lang.com/"
      ]
    },
    "missing_owner_check": {
      "name": "Missing Owner Check",
      "patterns": [
        "owner.key()",
        "assert_owned_by",
        "owner validation"
      ],
      "severity": "CRITICAL",
      "description": "Account owners are not validated. Attacker can pass accounts they don't own.",
      "remediation": "Always verify owner: require!(account.owner == expected_owner_pubkey)",
      "examples": [
        "WRONG: Let user pass any account without owner check",
        "RIGHT: #[account(owner = token_program.key())]"
      ],
      "references": [
        "https://docs.anchor-lang.com/"
      ]
    },
    "unchecked_account": {
      "name": "Unchecked Account Injection",
      "patterns": [
        "UncheckedAccount",
        "AccountInfo<'info>",
        "no constraints"
      ],
      "severity": "CRITICAL",
      "description": "Using UncheckedAccount or AccountInfo without constraints allows arbitrary account injection.",
      "remediation": "Use Account<T> with proper constraints. Or manually verify account properties.",
      "examples": [
        "WRONG: pub user: AccountInfo<'info>  // Unchecked, could be any account",
        "RIGHT: pub user: Account<'info, User>  // Checked and deserialized"
      ],
      "references": [
        "https://docs.anchor-lang.com/"
      ]
    },
    "arithmetic_overflow": {
      "name": "Arithmetic Overflow/Underflow",
      "patterns": [
        "+= ",
        "-= ",
        "* ",
        "wrapping_add",
        "unchecked"
      ],
      "severity": "HIGH",
      "description": "Rust arithmetic with u64/u128 can overflow. Use checked operations.",
      "remediation": "Use checked_add, checked_mul, checked_sub instead of wrapping operations",
      "examples": [
        "WRONG: vault.balance += amount;  // Can overflow",
        "RIGHT: vault.balance = vault.balance.checked_add(amount)?;"
      ],
      "references": [
        "https://docs.rs/num-traits/"
      ]
    },
    "rent_exempt": {
      "name": "Rent Exemption Violation",
      "patterns": [
        "lamports",
        "rent",
        "transfer"
      ],
      "severity": "MEDIUM",
      "description": "Transferring lamports can violate rent exemption requirement. Accounts must maintain minimum balance.",
      "remediation": "After transferring lamports, verify account still meets rent requirement",
      "examples": [
        "WRONG: Transfer lamports without checking rent exemption",
        "RIGHT: Verify rent.is_exempt(account.lamports(), account.data.len())"
      ],
      "references": [
        "https://docs.solana.com/developing/programming-model/accounts"
      ]
    }
  },
  "web2": {
    "sql_injection": {
      "name": "SQL Injection",
      "patterns": [
        "execute(",
        "query(",
        "SELECT",
        "+ user",
        "+ input",
        "f\"",
        "f'"
      ],
      "severity": "CRITICAL",
      "description": "User input concatenated directly into SQL queries. Attacker can inject SQL commands to read/modify/delete database.",
      "remediation": "Use parameterized queries (prepared statements). Never concatenate user input into queries.",
      "examples": [
        "WRONG: query = 'SELECT * FROM users WHERE id = ' + user_id",
        "RIGHT: query = 'SELECT * FROM users WHERE id = ?'; execute(query, [user_id])"
      ],
      "references": [
        "OWASP A03:2021",
        "https://owasp.org/www-community/attacks/SQL_Injection"
      ],
      "exclude_patterns": [
        "?",
        "prepared",
        "parameterized",
        "sanitize",
        "escape"
      ],
      "required_context": [
        "select",
        "insert",
        "update",
        "delete"
      ],
      "context_window": 3
    },
    "xss": {
      "name": "Cross-Site Scripting (XSS)",
      "patterns": [
        "innerHTML",
        "dangerouslySetInnerHTML",
        "eval(",
        "document.write",
        ".html("
      ],
      "severity": "HIGH",
      "description": "User input rendered as HTML/JavaScript without sanitization. Attacker can inject malicious scripts.",
      "remediation": "Sanitize all user input. Use textContent instead of innerHTML. Use DOMPurify or similar libraries.",
      "examples": [
        "WRONG: element.innerHTML = user_input;  // User can inject <script>",
        "RIGHT: element.textContent = user_input;  // Always plain text"
      ],
      "references": [
        "OWASP A07:2021",
        "https://owasp.org/www-community/attacks/xss/"
      ]
    },
    "csrf": {
      "name": "Cross-Site Request Forgery (CSRF)",
      "patterns": [
        "POST",
        "PUT",
        "DELETE",
        "form",
        "fetch(",
        "axios"
      ],
      "severity": "MEDIUM",
      "description": "State-changing requests (POST/PUT/DELETE) don't verify CSRF tokens. Attacker can trick user into making unwanted requests.",
      "remediation": "Implement CSRF tokens. Validate tokens on all state-changing operations. Use SameSite cookies.",
      "examples": [
        "WRONG: <form method='POST' action='/transfer'><input name='amount'></form>  // No CSRF token",
        "RIGHT: Include CSRF token in form and validate server-side"
      ],
      "references": [
        "OWASP A01:2021",
        "https://owasp.org/www-community/attacks/csrf"
      ]
    },
    "hardcoded_secrets": {
      "name": "Hardcoded Secrets",
      "patterns": [
        "PRIVATE_KEY",
        "password =",
        "API_KEY =",
        "secret =",
        "token =",
        "credentials"
      ],
      "severity": "CRITICAL",
      "description": "API keys, passwords, private keys in source code. Attacker can use them to compromise accounts.",
      "remediation": "Move all secrets to environment variables. Use secret management systems (AWS Secrets Manager, HashiCorp Vault).",
      "examples": [
        "WRONG: PRIVATE_KEY = '0xabc123...'  // In source code",
        "RIGHT: PRIVATE_KEY = os.getenv('PRIVATE_KEY')  // From environment"
      ],
      "references": [
        "OWASP A02:2021",
        "https://www.owasp.org/index.php/Secrets_Management_Cheat_Sheet"
      ],
      "exclude_patterns": [
        "os.getenv",
        "process.env",
        "config.",
        "settings.",
        "= ''",
        "= \"\"",
        "= None",
        "# example"
      ]
    },
    "broken_authentication": {
      "name": "Broken Authentication",
      "patterns": [
        "md5(",
        "sha1(",
        "password ==",
        "== true"
      ],
      "severity": "CRITICAL",
      "description": "Weak password hashing (MD5, SHA1) or flawed auth logic. Attacker can crack passwords or bypass authentication.",
      "remediation": "Use strong hashing: bcrypt, Argon2, scrypt. Implement proper authentication flow. Use JWT securely.",
      "examples": [
        "WRONG: hashlib.md5(password).hexdigest()  // MD5 is weak",
        "RIGHT: bcrypt.hashpw(password, bcrypt.gensalt())  // Strong"
      ],
      "references": [
        "OWASP A07:2021"
      ]
    },
    "insecure_deserialization": {
      "name": "Insecure Deserialization",
      "patterns": [
        "pickle.loads",
        "yaml.load",
        "unserialize",
        "ObjectInputStream"
      ],
      "severity": "CRITICAL",
      "description": "Deserializing untrusted data can execute arbitrary code. Attacker can inject malicious objects.",
      "remediation": "Use safe deserialization: pickle.safe_load, yaml.safe_load, JSON parsing.",
      "examples": [
        "WRONG: data = pickle.loads(user_input)  // Can execute code",
        "RIGHT: data = json.loads(user_input)  // Safe"
      ],
      "references": [
        "OWASP A08:2021"
      ]
    },
    "path_traversal": {
      "name": "Path Traversal",
      "patterns": [
        "../",
        "..\\",
        "open(",
        "readFile(",
        "os.path"
      ],
      "severity": "HIGH",
      "description": "User input used in file paths without validation. Attacker can read arbitrary files.",
      "remediation": "Validate file paths. Use allowlists. Resolve paths and verify they're within allowed directory.",
      "examples": [
        "WRONG: open(f'/uploads/{user_filename}')  // User can pass '../../etc/passwd'",
        "RIGHT: Validate filename against allowlist"
      ],
      "references": [
        "OWASP A01:2021"
      ]
    },
    "command_injection": {
      "name": "Command Injection",
      "patterns": [
        "os.system(",
        "exec(",
        "subprocess(",
        "shell=True",
        "shell_exec"
      ],
      "severity": "CRITICAL",
      "description": "User input passed to shell commands. Attacker can execute arbitrary commands.",
      "remediation": "Never use shell=True. Use parameterized system calls. Use libraries that don't involve shell.",
      "examples": [
        "WRONG: os.system(f'rm {user_input}')  // User can inject commands",
        "RIGHT: os.remove(sanitized_path)  // Direct operation"
      ],
      "references": [
        "OWASP A03:2021"
      ]
    },
    "weak_randomness": {
      "name": "Weak Randomness",
      "patterns": [
        "Math.random",
        "random.random",
        "rand()",
        "seed("
      ],
      "severity": "CRITICAL",
      "description": "Using non-cryptographic RNG for security purposes. Attacker can predict random values.",
      "remediation": "Use cryptographically secure RNG: os.urandom, secrets, crypto.getRandomBytes",
      "examples": [
        "WRONG: nonce = int(Math.random() * 1000)  // Predictable",
        "RIGHT: nonce = secrets.randbytes(32)  // Cryptographically secure"
      ],
      "references": [
        "OWASP A02:2021"
      ]
    },
    "weak_hash": {
      "name": "Weak Cryptographic Hash",
      "patterns": [
        "md5(",
        "sha1(",
        "CRC32",
        "hashlib.md5"
      ],
      "severity": "HIGH",
      "description": "Using weak hash functions (MD5, SHA1) for security. Attacker can find collisions.",
      "remediation": "Use SHA-256 or stronger: SHA-256, SHA-384, SHA-512, BLAKE2",
      "examples": [
        "WRONG: hashlib.md5(password).hexdigest()  // Weak",
        "RIGHT: hashlib.sha256(password).hexdigest()  // Strong"
      ],
      "references": [
        "OWASP"
      ]
    }
  },
  "defi": {
    "oracle_manipulation": {
      "name": "Price Oracle Manipulation",
      "patterns": [
        "getPrice(",
        "price.feed",
        "balanceOf",
        "getAmountsOut"
      ],
      "severity": "CRITICAL",
      "description": "Using unverified price source (e.g., Uniswap spot price) allows price manipulation via flash loans.",
      "remediation": "Use trusted oracles: Chainlink. Use time-weighted average prices (TWAP). Use multiple sources.",
      "examples": [
        "WRONG: price = uniswapPool.getAmountsOut(1 ether, [token])  // Can be manipulated",
        "RIGHT: price = chainlinkFeed.latestRoundData()  // Trusted oracle"
      ],
      "references": [
        "https://github.com/Uniswap/v3-core/issues"
      ]
    },
    "slippage": {
      "name": "Missing Slippage Protection",
      "patterns": [
        "swap(",
        "addLiquidity(",
        "0,",
        "minAmount"
      ],
      "severity": "MEDIUM",
      "description": "Swaps without slippage limits. Attacker can sandwich-attack and steal value.",
      "remediation": "Add minAmountOut parameter. Validate received amount >= expected - slippage tolerance.",
      "examples": [
        "WRONG: swapExactTokensForTokens(amount, 0, path, msg.sender, deadline)  // 0 minimum",
        "RIGHT: swapExactTokensForTokens(amount, minAmountOut, path, msg.sender, deadline)"
      ],
      "references": [
        "https://github.com/Uniswap/v3-periphery"
      ]
    }
  }
}